<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">

<table COLS="3" width="%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="gl11_4.html">
<img SRC="Back.gif" BORDER="0"    >
</a>
</font>
</td>
<td width="%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0"    >
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="gl11_6.html">
<img SRC="For.gif" BORDER="0"    >
</a>
</font>
</td>
</tr>
</table>



<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<b>
<font size="4">

Оверлей

</font>
</b>
<br>
</font>
</p>


<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">
Как отмечалось в гл.9, максимальный размер модуля не может превышать 64 
Кбайта, однако количество модулей не ограничено, что дает возможность 
разрабатывать весьма крупные программы, занимающие, например, всю доступную 
оперативную память ПК (приблизительно 580 Кбайт). Тем не менее, в некоторых 
случаях и этот объем может оказаться недостаточным. Турбо Паскаль предоставляет 
в распоряжение программиста простой и достаточно эффективный механизм оверлея, с 
помощью которого можно создавать программы практически неограниченной длины 
(следует оговориться, что речь идет только о длине кода программы; два важных 
размера -длина сегмента данных и размер программного стека - в Турбо Паскале не 
могут превышать 64 Кбайта независимо от структуры программы).</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Оверлей - это такой способ использования оперативной памяти, при котором в 
один и тот же участок памяти, называемый оверлейным буфером, попеременно по мере 
надобности загружаются различные оверлейные (перекрывающиеся) модули. При этом 
все оверлейные модули в готовом к работе виде хранятся на диске, а в оперативной 
памяти в каждый момент находится лишь один активный модуль и, возможно, 
небольшое число неактивных.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Пусть, например, программа (рис. 11.1) состоит из главной части MAIN и двух 
модулей А к В, a LM, LA и LB - соответственно длина главной части и обоих 
модулей, причем LA &gt; LB. Тогда неоверлейная программа займет в памяти LM + LA 
+ LB байт, в то время как- оверлейная программа - лишь LM + LA байт.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">При исполнении оверлейной программы в память первоначально загружается 
главная часть и один из модулей, например, модуль А. Если в процессе исполнения 
программы встретится обращение к модулю В, программа приостановит свою работу, с 
диска в оверлейный буфер будет загружен модуль В (модуль А при этом частично 
уничтожается), после чего программа продолжит свою работу. Если в дальнейшем</font>
<font face="Arial, Helvetica, sans-serif" size="3">встретится обращение к А, точно таким же образом будет загружен модуль А, 
причем загрузка нужных модулей в оверлейный буфер осуществляется автоматически и 
программисту не нужно об этом заботиться.</font> 
</P>
<P align="center"><img border="0" src="11_1.jpg"    > 
</P>
<P align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b>Puc.11.1.</b> Пример структуры программы: а) неоверлейная; 6) оверлейная</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Описанный механизм выявляет главное преимущество оверлейной структуры: объем 
оперативной памяти, занимаемой оверлейной программой, определяется длиной ее 
главной части и наибольшего из перекрывающихся модулей, в то время как при 
неоверлейной структуре в этот объем входит суммарная длина всех модулей. Чем 
больше в программе оверлейных модулей и чем меньше длина наибольшего из них, тем 
больший выигрыш в памяти дает оверлейная структура. Однако совершенно очевиден и 
главный недостаток таких структур: на каждую-загрузку оверлейного модуля с диска 
в оверлейный буфер требуется дополнительное время, поэтому оверлейная программа 
будет исполняться с меньшей скоростью.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Работа оверлейных программ обеспечивается с помощью процедур и функций 
библиотечного модуля OVERLAY, входящего в библиотечный файл TURBO.TPL.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">При создании оверлейных программ нужно руководствоваться следующей 
последовательностью действий.</font> </P>
<ul>
  <li><font face="Arial, Helvetica, sans-serif" size="3">Выделить главную часть программы и разбить оставшуюся часть на несколько 
модулей. Отметим, что никаких дополнительных ограничений на модули, по сравнению 
с описанными в гл.9, не накладывается за одним исключением: в оверлейных модулях 
нельзя использовать процедуры обработки прерываний. Желательно продумать состав 
модулей таким образом, чтобы по возможности минимизировать количество их 
перезагрузок в оверлейный буфер в процессе исполнения программы.</font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="3">В главной части программы указать с помощью директив компилятора вида
     {$О 
&lt;имя&gt;} те модули, которые будут оверлейными, например:</font></li>
</ul>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">Program Main;&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> Uses CRT, DOS,Graph, Overlay, UnitA, UnitB;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">{$0 DOS}&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> {$0 UnitA}&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">{$O UnitB}</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Следует подчеркнуть, что из всех стандартных библиотечных модулей только один 
модуль DOS может быть оверлейным, остальные модули (CRT, Graph, Printer и т.д.) 
не могут объявляться оверлейными.</font> </P>
<ul>
  <li><font face="Arial, Helvetica, sans-serif" size="3">Предусмотреть перед первым по логике работы программы обращением к 
оверлейному модулю вызов процедуры инициализации оверлея OVRINIT. Здесь же, если 
это необходимо, следует установить размер оверлейного буфера и указать 
возможность использования расширенной памяти (см. ниже).</font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="3">В начале главной программы и каждого оверлейного модуля необходимо поместить 
директивы компилятора {$О+} и {$F+} или установить опции OPTIONS /COMPILE/FORCE 
FAR CALLS и OPTIONS/ COMPILE/ OVERLAYS ALLOWED (см. прил.1) в активное 
состояние, после чего откомпилировать программу на диск. Программа готова к 
работе.</font></li>
</ul>
<P><font face="Arial, Helvetica, sans-serif" size="3">Таким образом, все процедуры и функции в оверлейной программе должны 
использовать дальнюю модель вызова - это обязательное условие. Отметим, что 
попытка компиляции оверлейного модуля, в начале которого отсутствует директива 
{$О+} предполагается, что опция среды OPTIONS/COMPILE/OVERLAY ALLOWED 
неактивна), будет обнаружена компилятором, в то время как! неправильная 
(ближняя) модель вызова оверлейных подпрограмм компилятором не контролируется и 
может привести к непредсказуемым результатам при исполнении программы.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Далее, инициация оверлея (осуществляется вызовом процедуры OVRINIT, см. ниже) 
должна происходить до вызова любого из оверлейных модулей. Это требование 
кажется тривиальным, однако множество проблем в оверлейных программах обычно 
:вязано именно с ним. Дело в том, что обращение к оверлейному модулю может 
происходить еще до начала работы основной программы: напомню, что любой модуль 
(в том числе и оверлейный) может иметь инициирующую часть, которая исполняется 
перед началом работы основной программы. В связи с этим рекомендую 
придерживаться следующего простого правила: никогда не используйте оператор 
BEGIN в конце модуля, если Вам нет нужды в инициирующих действиях; пустая 
инициирующая часть содержит пустой оператор, которому будет передано управление 
на этапе инициации. Таким образом, пустая инициирующая часть оверлейного модуля 
очень часто может вызывать сообщение об ошибке периода исполнения с кодом 208 
(не установлена система управления оверлеем). Как же быть, если в оверлейном 
модуле все-таки нужна инициирующая часть? В этом случае можно рекомендовать 
следующий прием. Создайте лишний модуль, в котором будут пустыми все части, 
кроме инициирующей. В этой части разместите команды инициации оверлея. Новый 
модуль не должен быть оверлейным и его имя должно стоять в предложении USES 
основной программы перед именем любого оверлейного модуля. После компиляции 
такой программы инициация оверлея будет осуществляться перед выполнением любой 
другой инициирующей части и проблема будет решена.</font> </P>
<P align="center"><font face="Arial, Helvetica, sans-serif" size="3"><b>Процедура </b>OVRINIT.  </font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Инициализирует оверлейный файл. Обращение:</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">OVRINIT (&lt;имя&gt;)</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Здесь &lt;имя&gt; - выражение типа STRING; имя файла с оверлейной частью 
программы.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">При компиляции оверлейной программы создается специальный файл с именем,
совпадающим с именем главной программы, и расширением .OVR. В этот файл компилятор помещает все оверлейные модули, из него же эти модули загружаются в 
оверлейный буфер в процессе исполнения программы. Файл с оверлейной частью 
программы должен размещаться в том же каталоге, что и файл с главной частью (с 
расширением .ЕХЕ). Отметим, что имя оверлейного файла необходимо дополнять 
расширением .OVR.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Обычно размер оверлейного буфера определяется автоматически таким образом, 
чтобы в нем мог разместиться самый крупный из всех оверлейных модулей. 
Программист может увеличить размер буфера. Тогда при загрузке в буфер очередного 
модуля программа проверит, достаточно ли в буфере свободного места и, если 
достаточно, загрузит новый модуль сразу за старым, который, таким образом, не 
будет уничтожен. Такой механизм способствует минимизации потерь времени на 
перезагрузку модулей. Если установлен очень большой размер буфера, то в нем, 
возможно, смогут разместиться все оверлейные модули, однако в этом случае 
оверлейная структура становится просто ненужной.</font> </P>
<P align="center"><font face="Arial, Helvetica, sans-serif" size="3"><b>Процедура </b>OVRSETBUF.  </font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Устанавливает размер оверлейного буфера. Формат 
обращения:</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">OVRSETBUF (&lt;длина&gt;)</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Здесь &lt;длина&gt; - выражение типа LONGINT задает новую длину буфера в 
байтах не больше той, которую устанавливает сама система автоматически. 
Расширение буфера идет за счет соответствующего уменьшения доступной 
динамической памяти, поэтому к моменту вызова этой процедуры куча должна быть 
пустой.</font> </P>
<P align="center"><font face="Arial, Helvetica, sans-serif" size="3"><b>Функция</b> OVRGETBUF.  </font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Возвращает значение типа LONGINT, содержащее текущий 
размер оверлейного буфера. Обращение:</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">OVRGETBUF</font> </P>
<P align="center"><font face="Arial, Helvetica, sans-serif" size="3"><b>Процедура </b>OVRINITEMS.  </font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Обеспечивает использование расширенной памяти. Если Ваш 
ПК относится к классу компьютеров типа IBM PC/AT и в нем имеется так называемая 
EMS-памятъ (Expanded Memory Specification - расширенная1 память, удовлетворяющая 
стандарту фирм Lotus/Intel/Microsoff). Вы можете использовать эту память для 
размещения в ней оверлейного файла .OVR. Поскольку время доступа к расширенной 
памяти значительно меньше времени чтения с диска, такое размещение увеличивает 
скорость исполнения оверлейной программы. Обращение:</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">OVRINITEMS</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">При обращении к этой процедуре программа прежде всего проверит, достаточен ли 
объем имеющейся в Вашем ПК EMS-памяти для размещения оверлейного файла. Если это 
так, то оверлейный файл считывается в EMS-память, сам файл закрывается, и 
программа будет получать оверлейные модули из этой памяти. Если же ЕMS-память 
отсутствует или ее объем недостаточен, обращение к процедуре игнорируется, и 
программа будет считывать оверлейные модули с диска.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Все управление оверлеем осуществляется стандартной подпрограммой, которая 
называется администратором оверлея. Эта подпрограмма получает управление всякий</font>
<font face="Arial, Helvetica, sans-serif" size="3">раз, когда программа обращается к ресурсам оверлейного модуля, не 
размещенного в данный момент в буфере. Администратор оверлея сначала перемещает 
предыдущий оверлейный модуль из буфера в так называемую контрольную зону, а уже 
затем грузит с диска в буфер новый модуль. Если в момент, когда оверлей 
находится в контрольной зоне, программа вновь обратится к нему, он вернется на 
свое старое место и таким образом затраты времени на обмен данными с диском 
будут уменьшены. Программист может задать размер контрольной зоны с помощью 
обращения к процедуре OVRSETRETRY и получить этот размер с помощью функции 
OVRGETRETRY. Обычно размер контрольной зоны составляет от одной трети до 
половины размера оверлейного буфера. Вы можете подобрать этот размер 
экспериментально в ходе пробного прогона программы. Для этого используются две 
переменные модуля OVERLAY:</font> 
</P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">var</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">OvrTrapCount: Word;{Счетчик обращений ,к администратору}</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">OvrLoadCount: Word;{Счетчик загрузок в оверлейный буфер}</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Всякое обращение программы к оверлейному модулю, которого нет в оверлейном 
буфере (в том числе и к модулю, находящемуся в контрольной зоне), приводит к 
наращиванию содержимого переменной OVRTRAPCOUNT на единицу. Всякая загрузка 
оверлейного модуля из файла в буфер увеличивает на единицу счетчик OVRLOADCOUNT.</font> 
</P>
<P><font face="Arial, Helvetica, sans-serif" size="3">В интерфейсной части модуля ОVERLAY объявлены еще три переменные, которые 
могут оказаться полезными для некоторых применений.</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">type</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vrReadFunc = Function (OvrSeg: Word): Integer;&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> var</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vrReadBuf : OvrReadFunc;{Функция чтения из оверлейного файла}</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vrResult :Integer;{Признак ошибки оверлея}</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vrFileMode:Byte;{Способ доступа к оверлейному файлу}</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Переменная OVRRESULT содержит код, указывающий на успех или неуспех каждой 
очередной операции администратора оверлея. Значения этой переменной могут быть 
такими:.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">0&nbsp; - операция прошла успешно;</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">-1 - общая ошибка;</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">-2 - не найден оверлейный файл;</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">-3 - не хватает памяти для оверлейного буфера;</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">-4 - ошибка чтения-записи оверлейного файла;</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">-5 - не работает драйвер EMS-памяти;</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">-6 - не хватает EMS-памяти.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Переменная OVRFILEMODE обычно содержит 0, что трактуется как возможность 
доступа к оверлейному файлу только для чтения информации. Перед вызовом 
процедуры OVRINIT программа может установить другое значение этой переменной и 
таким образом изменить доступ к файлу, что бывает необходимым, если ПК подключен 
к сети ЭВМ.</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">В переменной OVRREADBUF содержится имя функции, к которой обращается 
администратор оверлея при каждом чтении из оверлейного файла. Программа может</font>
<font face="Arial, Helvetica, sans-serif" size="3">перехватить обращение к этой функции и проанализировать результат операции. 
Для этого необходимо в основной программе сохранить имя стандартной функции 
чтения в глобальной переменной типа OVRREADFUNC и поместить в переменную 
OVRREADBUF имя новой функции. В эту новую функцию администратор будет передавать 
управление всякий раз, когда появится необходимость чтения из оверлейного файла. 
Программа может проверить состояние дисков перед исполнением операции (например, 
наличие нужного сменного диска), выполнить саму операцию (путем вызова функции, 
сохраненной в глобальной переменной), проверить результат обращения и 
предпринять необходимые действия. Отметим, что нормальное завершение операции 
чтения указывается нулевым значением функции чтения, ненулевое значение означает 
ту или иную ошибку; код ошибки стандартен для ДОС (см. прил.3) и/или для 
драйвера EMS-памяти.</font> 
</P>
<P><font face="Arial, Helvetica, sans-serif" size="3">При желании Вы можете пристыковать оверлейный файл в конец EXE-файла основной 
программы. При этом следует учесть, что интегрированная среда пристыковывает в 
конец EXE-файла отладочные таблицы, поэтому программу и все ее модули следует 
компилировать в режиме отключенных опций OPTIONS /COMPILER/DEBUG INFORMATION и 
OPTIONS/COMPILER/LOCAL SYMBOLS (см.прилЛ.2.8). Для объединения EXE-файла с 
оверлейным файлом необходимо дать такую команду ДОС:</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">СОРY /В NAME.EXE+NAME.OVR</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">Здесь NAME.EXE - имя EXE-файла, NAME.OVR - имя оверлейного файла. Чтобы 
оверлеи читались из ЕXE-файла, нужно просто указать имя этого файла при 
обращении к OVRINIT:</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">Ovrlnit(ParamStr(0));</font> </P>
<P><font face="Arial, Helvetica, sans-serif" size="3">(в программу всегда передается параметр ParamStr(0), в котором ДОС сообщает 
полное имя запущенной программы - с указанием диска и каталога, откуда была 
загружена программа).</font> </P>

<p>&nbsp;</p>

<table COLS="3" width="%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="gl11_4.html">
<img SRC="Back.gif" BORDER="0"    >
</a>
</font>
</td>
<td width="%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0"    >
</a>
</font>
</td>
<td ALIGN="RIGHT">
<font face="Arial, Helvetica, sans-serif">
<a href="gl11_6.html">
<img SRC="For.gif" BORDER="0"    >
</a>
</font>
</td>
</tr>
</table>

</BODY></HTML>