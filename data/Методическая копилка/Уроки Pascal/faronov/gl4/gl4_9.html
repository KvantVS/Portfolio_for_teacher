<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>
</title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080">

<table COLS="3" width="%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="gl4_8.html">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td width="%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>

<p>
&nbsp;
</p>
<p align="center">
<font face="Arial, Helvetica, sans-serif" size="3">
<b>
<font size="4">

Совместимость и преобразование типов

</font>
</b>
<br>
</font>
</p>


<p align="left">
<font face="Arial, Helvetica, sans-serif" size="3">
Как уже неоднократно отмечалось, Турбо Паскаль - это типизированный язык. Он 
построен на основе строгого соблюдения концепции типов, в соответствии с которой 
все применяемые в языке операции определены только над операндами совместимых 
типов. При обсуждении операций над вещественными данными мы уже затрагивали 
проблему совместимости вещественных и целых типов. Аналогичные проблемы 
возникают при операциях над строками разной длины, строками и символами и т.д. 
Ниже приводится более полное определение совместимости типов. </P>
<P>Два типа считаются совместимыми, если: </P>
<ul>
  <li>оба они есть один и тот же тип;</li>
  <li>оба вещественные;</li>
  <li>оба целые;</li>
  <li>один тип есть тип-диапазон второго типа;</li>
  <li>оба являются типами-диапазонами одного и того же базового типа;</li>
  <li>оба являются множествами, составленными из элементов одного и того же 
базового типа;</li>
  <li>оба являются упакованными строками (определены с предшествующим словом 
PACKED) одинаковой максимальной длины;</li>
  <li>один тип есть тип-строка, а другой - тип-строка, упакованная строка или 
символ;</li>
  <li>один тип есть любой указатель, а другой - нетипизированный указатель;</li>
  <li>один тип есть указатель на объект, а другой - указатель на родственный ему 
объект;</li>
  <li>оба есть процедурные типы с одинаковыми типом результата (для типа-функции), 
количеством параметров и типом взаимно соответствующих параметров.</li>
</ul>
<P>Совместимость типов приобретает особое значение в операторах присваивания. 
Пусть T1 - тип переменной, а Т2 - тип выражения, т.е. выполняется присваивание 
T1 := T2. Это присваивание возможно в следующих случаях: </P>
<ul>
  <li>T1 и T2 есть один и тот же тип и этот тип не относится к файлам или массивам 
файлов, или записям, содержащим поля-файлы, или массивам таких записей;</li>
  <li>T1 и T2 являются совместимыми порядковыми типами и значение T2 лежит в 
диапазоне возможных значений T1;</li>
  <li>T1 и T2 являются вещественными типами и значение
    T2 лежит в диапазоне 
возможных значений T1;</li>
  <li>T1 - вещественный тип и T2 - целый тип; ,</li>
  <li>T1 - строка и T2 - символ;</li>
  <li>T1 - строка и T2 - упакованная строка;</li>
  <li>T1 и T2 - совместимые упакованные строки;</li>
  <li>T1 и T2 - совместимые множества и все члены T2 принадлежат множеству 
возможных значений T1;</li>
  <li>T1 и T2 - совместимые указатели;</li>
  <li>T1 и T2 - совместимые процедурные типы;</li>
  <li>T1 - объект и T2 - его потомок.</li>
</ul>
<P>В программе данные одного типа могут преобразовываться в данные другого типа. 
Такое преобразование может быть явным или неявным. </P>
<P>При явном преобразовании типов используются вызовы специальных функций 
преобразования, аргументы которых принадлежат одному типу, а значение - другому. 
Таковыми являются уже рассмотренные функции ORD, TRUNC, ROUND, CHR. В гл. 6 
описывается функция PTR, преобразующая четырехбайтный целочисленный аргумент к 
типу-указателю. </P>
<P>В Турбо Паскале может использоваться и более общий механизм преобразования 
типов, согласно которому преобразование достигается применением идентификатора 
имени) стандартного типа или типа, определенного пользователем, как 
идентификатора функции преобразования к выражению преобразуемого типа (так 
называемое автоопределенное преобразование типов). Например, допустимы следующие 
вызовы функций: </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">type</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">МуТуре = (а, Ь, с, d);</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">.....</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">МуТуре (2)&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> Integer ('D')&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> pointer (longint(a)+ $FF)</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">Char (127 mod c)&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> Byte (k)</font> </P>
<P>При автоопределенном преобразовании типа выражения может произойти изменение 
длины его внутреннего представления (длина может увеличиться или уменьшиться). 
</P>
<P>В Турбо Паскале определен еще один явный способ преобразования данных: в ту 
область памяти, которую занимает переменная некоторого типа, можно поместить 
значение выражения другого типа, если только длина внутреннего представления 
вновь размещаемого значения в точности равна длине внутреннего представления 
переменной. С этой целью вновь используется автоопределенная функция
преобразования типов, но уже в левой части оператора присваивания: </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">type</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">byt = array [1..2] of Byte;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int = array [1..2] of Integer;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">rec = record</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">x, у : Integer&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">end;&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> var</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vbyt : byt;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vint : int;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">vrec : rec;&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> begin</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">byt(vint[1])[2] := 0;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">int(vrec)[1] := 256&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">end.</font> </P>
<P>Неявное преобразование типов возможно только в двух случаях: </P>
<ul>
  <li>в выражениях, составленных из вещественных и целочисленных переменных, 
последние автоматически преобразуются к вещественному типу, и все выражение в 
целом приобретает вещественный тип;</li>
  <li>одна и та же область памяти попеременно трактуется как содержащая данные то 
одного, то другого типа (совмещение в памяти данных разного типа).</li>
</ul>
<P>Совмещение данных в памяти может произойти при использовании записей с 
вариантными полями (см. 4.2.2), типизированных указателей, содержащих одинаковый 
адрес (см. гл. 6), а также при явном размещении данных разного типа по одному и 
тому же абсолютному адресу. Для размещения переменной по нужному абсолютному 
адресу она описывается с последующей стандартной директивой ABSOLUTE, за которой 
помещается либо абсолютный адрес, либо идентификатор ранее определенной 
переменной. Абсолютный адрес указывается парой чисел типа WORD, разделенных 
двоеточием; первое число трактуется как сегмент, второе - как смещение адреса 
(см. гл. 6). Например: </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">b : Byte absolute $0000:$0055; w : Longlnt absolute 128:0;</font> </P>
<P>Если за словом ABSOLUTE указан идентификатор ранее определенной переменной, 
то происходит совмещение в памяти данных разного типа, причем первые байты 
внутреннего представления этих данных будут располагаться по одному и тому же 
абсолютному адресу, например: </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">var</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">х : Real;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">у : array [1..3] of Integer absolute x;</font> </P>
<P>В этом примере переменные X и Y будут размещены, начиная с одного и того же 
абсолютного адреса. Таким образом, одну и ту же область памяти длиной 6 байт, а 
следовательно, и размещенные в этой области данные теперь можно рассматривать 
как данные либо типа REAL, либо как массив из трех данных типа INTEGER. 
Например, следующая программа выдаст на экран содержимое первых двух байт 
внутреннего представления вещественного числа п = 3.1415 в виде целого числа: 
</P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">var</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">х : Real; у : array[1..3] of Integer absolute x;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">begin</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">х := pi; WriteLn(y[1])&nbsp;</font> </P>
<P><font face="Verdana, Arial, Helvetica, sans-serif" size="3">end.</font> </P>
<P>На экран будет выдан результат 8578. </P>
<P>Неявные преобразования типов могут служить источником трудно обнаруживаемых 
ошибок в программе, поэтому везде, где это возможно, следует избегать их. 
</P>

<p>&nbsp;</p>

<table COLS="3" width="%">
<tr>
<td>
<font face="Arial, Helvetica, sans-serif">
<a href="gl4_8.html">
<img SRC="Back.gif" BORDER="0">
</a>
</font>
</td>
<td width="%">
<font face="Arial, Helvetica, sans-serif">
<a href="../index.html">
<img SRC="Menu.gif" BORDER="0">
</a>
</font>
</td>
</tr>
</table>

</BODY></HTML>